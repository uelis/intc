fn fiximpl(x) =
    case x of 
    Inl(l, x) -> 
        (case x of
           Inl(b, q) ->
             push(unit + 'b, Inr(b));
             return Inl((), Inr(q))
         | Inr(a) ->
	     let u = pop(unit + 'b) in
             (case u of 
                Inl -> return Inr(a)
              | Inr(hd) ->
                   return Inl((), Inl(hd, a))))
  | Inr(q) -> 
     push(unit + 'b, Inl());
     return Inl((), Inr(q))

let fix = direct(fiximpl:(''a -> ''a) -> ''a)

let val = λ n -> λ k -> k n
let add = λ k -> k (λ n -> λ k1 -> 
                            let nv = n in
                            k1 (λ m -> λ k2 -> 
                                    let mv = m in
                                    k2 (nv+mv) 
                               )
                   )
let app = λ e1 -> λ e2 -> λ k -> e1 (λ x1 -> e2 (λ x2 -> x1 x2 k))
let mem = λ f -> λ k ->  k (f (λ r -> r))

let step =
   λ f ->
   copy f as f1, f2 in
     val (λ x -> 
          mem (λ k ->
              let xv = x in
	      let b = intslt(xv, 2) in
              (if b then 
                 val (return 1) k 
              else
                app (app add (f1 (xv - 1))) (f2 (xv - 2)) k)
            )
         )
let fixv = fix (λ a -> step (λ x -> λ k -> a (λ b -> b x k))) 

let main =
   let v = app fixv (val (return 38)) (λ r -> r) in
   print v


let fixsimpl = fn x {
    case x of 
    Inl(l, x) -> 
        (case x of
           Inl(b, q) ->
             push(unit + 'b, Inr(b));
             Inl((), Inr(q))
         | Inr(a) ->
             (case pop(unit + 'b) of 
                Inl -> Inr(a)
              | Inr(hd) ->
                   Inl((), Inl(hd, a))))
  | Inr(q) -> 
     push(unit + 'b, Inl());
     Inl((), Inr(q))
}
let fix = hack(fixsimpl: {unit}| {'c}|''a| -> ''a| -> ''a)

let val = fun n -> fun k -> k n
let add = fun k -> k (fun n -> fun k1 -> 
                          fn () {
                            let nv = n() in
                            k1 (fun m -> fun k2 -> 
                                  fn () { 
                                    let mv = m() in
                                    k2 (fn() { nv+mv }) ()
                                  }) ()
                          })
let if0 = fun x1 -> fun x2 -> fun k -> k (fun n -> fun k ->
                      fn () {
                        let b = n() = 0 in
                        (if b then x1 k else x2 k) ()
                      })
let app = fun e1 -> fun e2 -> fun k -> e1 (fun x1 -> e2 (fun x2 -> x1 x2 k))
let mem = fun f -> fun k ->  k (f (fun r -> r))

let step =
   fun f ->
   copy f as f1, f2 in
     val (fun x -> 
          mem (fun k ->
            fn () {
              let xv = x() in
              (if xv < 2 then 
                 val (fn() { 1 }) k 
              else
                app (app add (f1 (fn(){ xv - 1 }))) (f2 (fn(){ xv - 2 })) k) ()
            }))

let fixv = fix (fun a -> step (fun x -> fun k -> a (fun b -> b x k))) 

fn main() {
   let v = app fixv (val (fn(){ 38 })) (fun r -> r) () in
   print v
}

